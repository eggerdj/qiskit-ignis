# This code is part of Qiskit.
#
# (C) Copyright IBM 2020.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""Base class of calibration analysis."""

from collections import defaultdict
from dataclasses import dataclass
from typing import Dict, Optional, Any, Iterator, List, Tuple, Union

import numpy as np
import pandas as pd
from qiskit.result import Result, Counts
from scipy import optimize

from qiskit.ignis.experiments.base import Analysis
from qiskit.ignis.experiments.calibration.cal_metadata import CalibrationMetadata
from qiskit.ignis.experiments.calibration.data_processing import DataProcessingSteps


class BaseCalibrationAnalysis(Analysis):
    """
    A base analysis for calibration.
    """

    def __init__(self,
                 name: Optional[str] = None,
                 data: Optional[Any] = None,
                 metadata: Optional[Dict[str, Any]] = None,
                 exp_id: Optional[str] = None,
                 data_processing_steps: Optional[DataProcessingSteps] = None):
        """Initialize calibration experiment analysis

        Args:
            name: Name of this analysis.
            data: Result data to initialize with.
            metadata: Metadata to initialize with.
            exp_id: Experiment id string.
            data_processing_steps: the steps to process the data with.

        Additional Information:
            Pulse job doesn't return marginalized result.
            Result memory slot is marginalized with qubits specified in metadata.

            Users do not need to take care of data format.
            Data is automatically processed based on the give workflow.
        """
        # Workflow for measurement data processing
        self._data_processing_steps = data_processing_steps
        self._x_values = set()

        super().__init__(data=data,
                         metadata=metadata,
                         name=name,
                         exp_id=exp_id)

    @property
    def x_values(self) -> List[str]:
        """X-values of the data."""
        return list(self._x_values)

    @property
    def data_processing_steps(self):
        """Return data processing steps."""
        return self._data_processing_steps

    @data_processing_steps.setter
    def data_processing_steps(self, data_processing_steps: DataProcessingSteps):
        """Set data processing steps."""
        self._data_processing_steps = data_processing_steps

    def experiment_data(self) -> pd.DataFrame:
        """Return experimental data as table.

        DataFrame is generated from the formatted experiment data and metadata.
        Data vectors to fit are generated by a helper method `_get_target_data`.
        Users can customize data vector based on data structure of experiment.
        """
        xval_columns = [name for name in sorted(self.x_values)]
        yval_columns = ['series', 'qubit', 'experiment', 'value']

        experiment_results = pd.DataFrame(columns=xval_columns + yval_columns)

        for data, meta in zip(self.data, self.metadata):
            meta = CalibrationMetadata(**meta)

            for slot_ind, qubit in enumerate(meta.qubits):
                data_dict = dict()
                for param_name, scan_val in meta.x_values.items():
                    data_dict[param_name] = scan_val
                data_dict['series'] = meta.series
                data_dict['qubit'] = qubit
                data_dict['experiment'] = meta.name
                data_dict['value'] = data[slot_ind]
                experiment_results = experiment_results.append(data_dict, ignore_index=True)

        return experiment_results

    def initial_guess(self,
                      xvals: np.ndarray,
                      yvals: np.ndarray) -> Iterator[np.ndarray]:
        """Create initial guess for fit parameters.

        Args:
            xvals: x values to fit.
            yvals: y values to fit.

        Yield:
            Set of initial guess for parameters.
            If multiple guesses are returned fit is performed for all parameter set.
            Error is measured by Chi squared value and the best fit result is chosen.

        Note:
            This should return values with yield rather than return.
        """
        raise NotImplementedError

    def fit_boundary(self,
                     xvals: np.ndarray,
                     yvals: np.ndarray) -> List[Tuple[float, float]]:
        """Returns boundary of parameters to fit.

        Args:
            xvals: x values to fit.
            yvals: y values to fit.
        """
        raise NotImplementedError

    def fit_function(self, xvals: np.ndarray, *args) -> np.ndarray:
        """Fit function.

        Args:
            xvals: x values to fit.
        """
        raise NotImplementedError

    def chi_squared(self,
                    parameters: np.ndarray,
                    xvals: np.ndarray,
                    yvals: np.ndarray):
        """Calculate reduced Chi squared value.

        Args:
            parameters: Parameters for fit function.
            xvals: X values to fit.
            yvals: Y values to fit.
        """
        fit_yvals = self.fit_function(xvals, *parameters)

        chi_sq = np.sum((fit_yvals - yvals) ** 2)
        dof = len(xvals) - len(parameters)

        return chi_sq / dof

    def plot(self,
             qubits: Optional[Union[int, List[int]]] = None,
             tags: Optional[Union[str, List[str]]] = None,
             ax: Optional['Axis'] = None,
             **kwargs) -> 'Figure':
        """Plot analysis result.

        Args:
            qubits: List of qubit to show.
            tags: List of fit line names to show.
            ax: Matplotlib Axis object to plot the analysis results.
        """
        import matplotlib
        import matplotlib.pyplot as plt
        from matplotlib.pyplot import cm

        if isinstance(qubits, int):
            qubits = [qubits]

        if isinstance(tags, str):
            tags = [tags]

        if ax:
            figure = ax.figure
        else:
            figure = plt.figure(figsize=kwargs.get('figsize', (6, 4)))
            ax = figure.add_subplot(111)

        line_counts = 0
        for analyzed_qubit, series_data in self.result.items():
            if qubits and analyzed_qubit not in qubits:
                # this qubit is not specified.
                continue
            for data_tag, fit_result in series_data.items():
                if tags and data_tag not in tags:
                    # this tag is not specified.
                    continue

                # plot fit line
                xval_interp = np.linspace(fit_result.xvals[0], fit_result.xvals[-1], 100)
                yval_fit = self.fit_function(xval_interp, *fit_result.fitvals)

                fit_line_color = cm.tab20.colors[(2*line_counts+1) % cm.tab20.N]
                data_label = '{tag} (Q{qubit:d})'.format(tag=data_tag, qubit=analyzed_qubit)
                ax.plot(xval_interp, yval_fit, '--', color=fit_line_color, label=data_label)

                # plot data scatter
                data_scatter_color = cm.tab20.colors[(2*line_counts) % cm.tab20.N]
                ax.plot(fit_result.xvals, fit_result.yvals, 'o', color=data_scatter_color)

                ax.set_xlim(fit_result.xvals[0], fit_result.xvals[-1])

        ax.set_xlabel(kwargs.get('xlabel', kwargs.get('xlabel', 'Parameter')), fontsize=14)
        ax.set_ylabel(kwargs.get('ylabel', kwargs.get('ylabel', 'Signal')), fontsize=14)
        ax.grid()
        ax.legend()

        if matplotlib.get_backend() in ['module://ipykernel.pylab.backend_inline',
                                        'nbAgg']:
            plt.close(figure)

        return figure

    def run(self, qubit: int, **kwargs) -> any:
        """Analyze the stored data.

        Args:
            qubit: Index of qubit to analyze the result.

        Returns:
            any: the output of the analysis,
        """
        qubit_data = self.experiment_data().groupby('qubit').get_group(qubit)
        temp_results = dict()

        # fit for each initial guess
        for xvals, yvals, tag in self._get_target_data(qubit_data):
            # fit for each series
            best_result = None
            for initial_guess in self.initial_guess(xvals, yvals):
                # fit for each initial guess if there are many starting point
                fit_result = optimize.minimize(
                    fun=self.chi_squared,
                    x0=initial_guess,
                    args=(xvals, yvals),
                    bounds=self.fit_boundary(xvals, yvals),
                    **kwargs
                )
                if fit_result.success:
                    if not best_result or best_result.chisq > fit_result.fun:
                        best_result = FitResult(
                            fitvals=fit_result.x,
                            chisq=fit_result.fun,
                            xvals=xvals,
                            yvals=yvals
                        )
                else:
                    # fit failed, output log `fit_result.message`
                    pass
            # keep the best result
            temp_results[tag] = best_result

        # update analysis result
        if self._result:
            self._result[qubit] = temp_results
        else:
            self._result = {qubit: temp_results}

        return temp_results

    def _format_data(self,
                     data: Result,
                     metadata: Dict[str, any],
                     index: int) -> Counts:
        """Format the required data from a Result.data dict"""
        metadata = CalibrationMetadata(**metadata)

        for xval in metadata.x_values.keys():
            self._x_values.add(xval)

        return self._data_processing_steps.format_data(
            result=data,
            metadata=metadata,
            index=index
        )

    def _get_target_data(self, data: pd.DataFrame) -> Iterator[Tuple[np.ndarray, np.ndarray, str]]:
        """Format fit values from data frame.

        User can generate arbitrary data set to fit with tag.
        Each data (xvals, yvals) in the data set should be returned as iterator
        with the tagged name. Analysis `.run` method receives this data and perform fitting.
        User can overwrite this method with respect to the data structure that
        generator defines.

        Args:
            data: Data source. The table has column of fit parameter names defined by
                associated generator, series, experiment, and value.

        Yield:
            Set of xvalue and yvalue vectors with string representation of the data.
        """
        if len(self.x_values) > 1:
            pass

        grouped_data = data.groupby(['series', 'experiment']).agg({
            self.x_values[0]: list, 'value': list})

        for composite_key, sub_data in grouped_data.iterrows():
            xvals = np.asarray(data[self.x_values[0]])
            yvals = np.asarray(data['value'])

            yield xvals, yvals, '.'.join(composite_key)


@dataclass(frozen=True)
class FitResult:
    """A data class that store fitting results."""
    # required parameters

    # fit parameters
    fitvals: np.ndarray
    # chi squared value of fitting
    chisq: float

    # optional information about fitting

    # standard deviation of parameters
    stdevs: np.ndarray = np.array([])
    # horizontal axis data values, may be used for visualization
    xvals: np.ndarray = np.array([])
    # vertical axis data values, may be used for visualization
    yvals: np.ndarray = np.array([])

    def to_dict(self):
        """Serialize result."""
        return {
            'fit_vals': list(self.fitvals),
            'chisq': self.chisq,
            'stedevs': list(self.stdevs),
            'xvals': list(self.xvals),
            'yvals': list(self.yvals)
        }

    def __repr__(self) -> str:
        return 'FitResult({})'.format(','.join(map(str, self.fitvals)))
